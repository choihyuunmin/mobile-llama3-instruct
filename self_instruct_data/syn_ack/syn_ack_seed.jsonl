{"id": "seed_task_1", "name": "Detect SYN Flood Attack", "instruction": "Write a Python script using Scapy to detect potential SYN flood attacks in real-time by monitoring SYN packet rates from different IPs.", "instances": [{"input": "Monitor incoming TCP SYN packets and trigger an alert if an IP sends more than 5000 SYN packets within an hour.", "output": "from scapy.all import sniff, TCP, IP\nfrom collections import defaultdict\nfrom datetime import datetime\n\nsyn_count = defaultdict(lambda: {'count': 0, 'timestamp': datetime.now()})\nalert_threshold = 5000\n\ndef packet_handler(pkt):\n    if pkt.haslayer(IP) and pkt.haslayer(TCP) and pkt[TCP].flags & 0x02:\n        src_ip = pkt[IP].src\n        current_time = datetime.now()\n        syn_count[src_ip]['count'] += 1\n        syn_count[src_ip]['timestamp'] = current_time\n        \n        if syn_count[src_ip]['count'] > alert_threshold:\n            print(f\"[ALERT] Possible SYN flood attack detected from {src_ip}! Count: {syn_count[src_ip]['count']}\")\n\nsniff(filter=\"tcp\", prn=packet_handler, store=False)"}]}
{"id": "seed_task_2", "name": "Track Hourly SYN Packet Trends", "instruction": "Create a script that resets SYN packet counters every hour and tracks SYN traffic trends for analysis.", "instances": [{"input": "Track SYN packets per source IP and reset the count every hour to monitor attack trends.", "output": "from scapy.all import sniff, TCP, IP\nfrom collections import defaultdict\nfrom datetime import datetime\n\nsyn_data = defaultdict(lambda: {'count': 0, 'last_hour': datetime.now().hour})\n\ndef reset_hourly():\n    current_hour = datetime.now().hour\n    for ip in list(syn_data.keys()):\n        if syn_data[ip]['last_hour'] != current_hour:\n            del syn_data[ip]\n\ndef analyze_packet(pkt):\n    if pkt.haslayer(IP) and pkt.haslayer(TCP) and pkt[TCP].flags & 0x02:\n        src_ip = pkt[IP].src\n        reset_hourly()\n        syn_data[src_ip]['count'] += 1\n        syn_data[src_ip]['last_hour'] = datetime.now().hour\n\nsniff(filter=\"tcp\", prn=analyze_packet, store=False)"}]}
{"id": "seed_task_3", "name": "Extract TCP Flags from Packets", "instruction": "Develop a script that captures network packets and extracts TCP flags from each packet for network diagnostics.", "instances": [{"input": "Capture TCP packets and log their flags to analyze network activity.", "output": "from scapy.all import sniff, TCP, IP\n\ndef log_tcp_flags(pkt):\n    if pkt.haslayer(TCP) and pkt.haslayer(IP):\n        print(f\"Source: {pkt[IP].src}, Destination: {pkt[IP].dst}, Flags: {pkt[TCP].flags}\")\n\nsniff(filter=\"tcp\", prn=log_tcp_flags, store=False)"}]}
{"id": "seed_task_4", "name": "SYN-ACK Response Rate Analysis", "instruction": "Build a script to track SYN packets and their corresponding SYN-ACK responses to measure response rates.","instances": [{"input": "Monitor SYN requests and compare with SYN-ACK responses to detect network irregularities.", "output": "from scapy.all import sniff, TCP, IP\nfrom collections import defaultdict\n\nsyn_requests = defaultdict(int)\nsyn_acks = defaultdict(int)\n\ndef track_syn_synack(pkt):\n    if pkt.haslayer(IP) and pkt.haslayer(TCP):\n        if pkt[TCP].flags & 0x02:\n            syn_requests[pkt[IP].src] += 1\n        elif pkt[TCP].flags & 0x12:\n            syn_acks[pkt[IP].dst] += 1\n\nsniff(filter=\"tcp\", prn=track_syn_synack, store=False)"}]}
{"id": "seed_task_5", "name": "Passive OS Fingerprinting", "instruction": "Develop a script that passively fingerprints operating systems based on network packet characteristics.", "instances": [{"input": "Analyze TCP window sizes and TTL values to infer the OS of network devices.", "output": "from scapy.all import sniff, IP, TCP\n\ndef fingerprint_os(pkt):\n    if pkt.haslayer(IP) and pkt.haslayer(TCP):\n        print(f\"Source: {pkt[IP].src}, TTL: {pkt[IP].ttl}, Window Size: {pkt[TCP].window}\")\n\nsniff(filter=\"tcp\", prn=fingerprint_os, store=False)"}]}
{"id": "seed_task_6", "name": "Detect Port Scanning", "instruction": "Write a script to identify potential port scanning activities by tracking connection attempts per source IP.", "instances": [{"input": "Monitor TCP SYN packets to detect excessive connection attempts across multiple ports.", "output": "from scapy.all import sniff, TCP, IP\nfrom collections import defaultdict\n\nscan_attempts = defaultdict(set)\n\ndef detect_scan(pkt):\n    if pkt.haslayer(IP) and pkt.haslayer(TCP) and pkt[TCP].flags & 0x02:\n        scan_attempts[pkt[IP].src].add(pkt[TCP].dport)\n        if len(scan_attempts[pkt[IP].src]) > 100:\n            print(f\"[ALERT] Possible port scanning detected from {pkt[IP].src}!\")\n\nsniff(filter=\"tcp\", prn=detect_scan, store=False)"}]}
{"id": "seed_task_7", "name": "HTTP Request Monitoring", "instruction": "Implement a script to monitor HTTP GET requests and log their sources.", "instances": [{"input": "Capture and log HTTP GET requests including source IPs and requested URLs.", "output": "from scapy.all import sniff, TCP, IP, Raw\n\ndef http_monitor(pkt):\n    if pkt.haslayer(TCP) and pkt.haslayer(Raw):\n        payload = pkt[Raw].load.decode(errors='ignore')\n        if 'GET' in payload:\n            print(f\"Source: {pkt[IP].src}, Request: {payload.split('GET ')[1].split(' ')[0]}\")\n\nsniff(filter=\"tcp port 80\", prn=http_monitor, store=False)"}]}
{"id": "seed_task_8", "name": "DNS Query Monitoring", "instruction": "Develop a script to capture and log DNS queries, identifying frequent requesters.", "instances": [{"input": "Monitor and log DNS queries along with source IPs to detect unusual activity.", "output": "from scapy.all import sniff, DNS, IP\nfrom collections import defaultdict\n\ndns_requests = defaultdict(int)\n\ndef dns_monitor(pkt):\n    if pkt.haslayer(DNS) and pkt.haslayer(IP):\n        src_ip = pkt[IP].src\n        dns_requests[src_ip] += 1\n        print(f\"Source: {src_ip}, DNS Query: {pkt[DNS].qd.qname.decode(errors='ignore')}\")\n\nsniff(filter=\"udp port 53\", prn=dns_monitor, store=False)"}]}
{"id": "seed_task_9", "name": "ICMP Ping Flood Detection", "instruction": "Create a Python script that monitors ICMP echo requests to detect potential ping flood attacks.", "instances": [{"input": "Capture ICMP packets and alert if an IP sends excessive echo requests in a short time.", "output": "from scapy.all import sniff, ICMP, IP\nfrom collections import defaultdict\nfrom datetime import datetime\n\nicmp_counts = defaultdict(lambda: {'count': 0, 'timestamp': datetime.now()})\nthreshold = 1000\n\ndef icmp_handler(pkt):\n    if pkt.haslayer(ICMP) and pkt[ICMP].type == 8:\n        src_ip = pkt[IP].src\n        icmp_counts[src_ip]['count'] += 1\n        icmp_counts[src_ip]['timestamp'] = datetime.now()\n        if icmp_counts[src_ip]['count'] > threshold:\n            print(f\"[ALERT] Possible ICMP flood from {src_ip}! Count: {icmp_counts[src_ip]['count']}\")\n\nsniff(filter=\"icmp\", prn=icmp_handler, store=False)"}]}
{"id": "seed_task_10", "name": "ARP Spoofing Detection", "instruction": "Write a script that detects ARP spoofing by identifying conflicting IP-MAC pairs.", "instances": [{"input": "Monitor ARP packets and detect inconsistent IP-MAC mappings to identify potential ARP spoofing attacks.", "output": "from scapy.all import sniff, ARP\narp_table = {}\n\ndef detect_arp_spoof(pkt):\n    if pkt.haslayer(ARP) and pkt[ARP].op == 2:\n        ip, mac = pkt[ARP].psrc, pkt[ARP].hwsrc\n        if ip in arp_table and arp_table[ip] != mac:\n            print(f\"[ALERT] ARP Spoofing Detected! IP: {ip}, Conflicting MACs: {arp_table[ip]} and {mac}\")\n        arp_table[ip] = mac\n\nsniff(filter=\"arp\", prn=detect_arp_spoof, store=False)"}]}     